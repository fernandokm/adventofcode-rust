//! Core AoC code.
//!
//! Provides the tools used to define AoC solutions ([`register!`])
//! and to read input data ([`input::Input`]).

// #![deny(clippy::missing_docs_in_private_items)]
// #![warn(clippy::pedantic)]
#![deny(rust_2018_idioms)]

use std::{
    fmt::Display,
    time::{Duration, Instant},
};

use input::InputSpec;
use linkme::distributed_slice;
use rustc_hash::FxHashMap;

pub mod input;

/// The error type for AoC solver errors.
#[derive(Debug, thiserror::Error)]
pub enum SolverError {
    /// Indicates that there was an IO error when printing the
    /// result given by a solver.
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),

    /// Indicates that a given solver is not implemented.
    /// This is usually generated by calling the [`not_implemented!`] macro.
    #[error("Not implemented")]
    NotImplemented,

    /// Wraps any other error raised by the solver.
    #[error("Solver error: {0}")]
    SolverError(#[source] anyhow::Error),
}

/// Indicates that a solver is not implemented by returning a
/// [`SolverError::NotImplemented`] error.
#[macro_export]
macro_rules! not_implemented {
    () => {
        return Err(::aoc::SolverError::NotImplemented.into())
    };
}

/// A specialized [`Result`] for AoC solver errors.
pub type Result<T> = std::result::Result<T, SolverError>;

/// Uniquely identifies an AoC problem.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ProblemId {
    /// The year in which the problem was published.
    pub year: u32,
    /// The day in which the problem was published
    /// (usually an integer from 1 to 25, inclusive).
    pub day: u32,
}

impl Display for ProblemId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "{}.{}", self.year, self.day)
    }
}

pub struct ProblemOutput<'a> {
    inner: Box<dyn ProblemOutputBackend + 'a>,
    last_instant: Instant,
    part_time: [Vec<Duration>; 2],
    output_enabled: bool,
}

impl<'a> ProblemOutput<'a> {
    pub fn start<B>(spec: &InputSpec, mut inner: B) -> Result<ProblemOutput<'a>>
    where
        B: ProblemOutputBackend + 'a,
    {
        inner.start(spec)?;
        Ok(ProblemOutput {
            inner: Box::new(inner),
            last_instant: Instant::now(),
            part_time: [Vec::new(), Vec::new()],
            output_enabled: true,
        })
    }

    pub fn disable_output(&mut self) {
        self.output_enabled = false;
    }

    pub fn enable_output(&mut self) {
        self.output_enabled = true;
    }

    fn try_set(&mut self, part: u32, solution: impl Display) -> Result<()> {
        debug_assert!(part == 1 || part == 2);

        self.part_time[(part - 1) as usize].push(self.last_instant.elapsed());
        self.reset_elapsed_time();
        if self.output_enabled {
            let times = &self.part_time[(part - 1) as usize];
            let exec_time = times.iter().sum::<Duration>() / times.len() as u32;
            let exec_time_err = if times.len() == 1 {
                None
            } else {
                let n = times.len() as f64;
                let sum_sqr_errs = times
                    .iter()
                    .map(|&t| {
                        let err_secs = t.as_secs_f64() - exec_time.as_secs_f64();
                        err_secs * err_secs
                    })
                    .sum::<f64>();
                let variance = sum_sqr_errs / (n - 1.0);
                Some(Duration::from_secs_f64(variance.sqrt()))
            };
            self.inner
                .set_solution(part, exec_time, exec_time_err, &solution)?;
        }
        Ok(())
    }

    pub fn set_part1(&mut self, solution: impl Display) {
        self.try_set_part1(solution)
            .expect("Unexpected error setting the output for part 1")
    }

    pub fn try_set_part1(&mut self, solution: impl Display) -> Result<()> {
        self.try_set(1, solution)
    }

    pub fn set_part2(&mut self, solution: impl Display) {
        self.try_set_part2(solution)
            .expect("Unexpected error setting the output for part 2")
    }

    pub fn try_set_part2(&mut self, solution: impl Display) -> Result<()> {
        self.try_set(2, solution)
    }

    pub fn reset_elapsed_time(&mut self) {
        self.last_instant = Instant::now()
    }
}

pub trait ProblemOutputBackend {
    fn start(&mut self, spec: &InputSpec) -> Result<()>;
    fn set_solution(
        &mut self,
        part: u32,
        exec_time: Duration,
        exec_time_err: Option<Duration>,
        solution: &dyn Display,
    ) -> Result<()>;
}

pub struct Solver {
    pub problem_id: ProblemId,
    pub raw_solve: fn(input: &str, out: &mut ProblemOutput<'_>) -> anyhow::Result<()>,
}

// TODO: derive(Debug) causes an error. Why?
impl std::fmt::Debug for Solver {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut builder = f.debug_struct("Solver");
        builder.field("problem_id", &self.problem_id);
        builder.field("raw_solve", &(self.raw_solve as *const ()));
        builder.finish()
    }
}

impl Solver {
    pub fn solve(&self, input: &str, out: &mut ProblemOutput<'_>) -> Result<()> {
        (self.raw_solve)(input, out).map_err(|e| match e.downcast() {
            Ok(e) => e,
            Err(e) => SolverError::SolverError(e),
        })
    }

    pub fn get_map() -> FxHashMap<ProblemId, &'static Solver> {
        let mut m: FxHashMap<ProblemId, &'static Solver> = FxHashMap::default();
        for s in SOLVERS {
            if m.insert(s.problem_id, s).is_some() {
                panic!("Multiple solver implementations for {}", s.problem_id);
            }
        }
        m
    }
}

#[distributed_slice]
pub static SOLVERS: [Solver] = [..];

#[macro_export]
macro_rules! register {
    ($solve_fn:path, $year:expr, $day:expr) => {
        ::paste::paste! {
            #[::linkme::distributed_slice(::aoc::SOLVERS)]
            static [<SOLVER_ $solve_fn _ $year _ $day>]: ::aoc::Solver = ::aoc::Solver {
                problem_id: ::aoc::ProblemId {
                    year: $year,
                    day: $day,
                },
                raw_solve: $solve_fn,
            };
        }
    };
}
